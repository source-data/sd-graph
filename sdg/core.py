
class CoreNode:
"""
parse from xml object with xpath
parse from json with key/indices
store into neo4j
retrieve from neo4j query
retrieve from REST request
serialize to xml
serialize to json
"""


class SDNode:

    def __init__(self, data: Dict):
        self._data = data
        if isinstance(self._data, list):
            self._data = self._data[0]
        self.properties = {'source': 'sdneo'}
        self.label = self.__class__.__name__
        self.children = []

    def update_properties(self, prop: Dict):
        self.properties = {**self.properties, **prop}

    @staticmethod
    def rm_empty(list):
        return [e for e in list if e]

    def get(self, key, default):
        # should never return None, but rather returns default value if value from self._data is None or [] or False
        val = self._data.get(key, default)
        if not val:
            val = default
        return val

    def __str__(self):
        return "; ".join([f"{k}: {v}" for k, v in  self._data.items()])


def XMLArticle(d: Dict):
    e = Element('article')
    e.attrib['doi'] = d['doi']
    e.attrib['id'] = str(d['id'])
    return e


lass XMLNode:
    """
    Nodes formed by recursively traversing the xml tree using the graph model.
    The properties of the nodes are generated by using the recipe provided by the graph model.
    Properties, including 'text' and 'tail', are only created if they are not empty or None.
    Terminal leaf nodes have no children and the innertext is then used as text property.
    The graph model provides the relationships to each subset of children.
    Each subset has an XPath to extract the respective children from the current element.

    Args:
        element (Element): the xml element to use to creat the node
        graph_model (Dict): the current graph model
        position_idx (int): the position of the element if it is part of a sequence
        namespaces (Dict): the dictionary of namespaces with their prefix

    Attributes:
        label (str): the node label
        properties (Dict): the properties of the node
        children (Dict): dictionary of childrens, where keys are relationship and value are the subgraph models

    """

    def __init__(self, element: Element, graph_model: Dict, position_idx: int = 0, namespaces: Dict = None):
        # this_element_path_was = graph_model['XPath']
        # this_element_children = graph_model['children']
        # this_element_xpath_to_properties = graph_model['properties']
        self.namespaces = namespaces
        self.label = cleanup_name(element.tag).capitalize()
        print(f"parsing {self.label} {position_idx}                               ", end="\r")
        recipe_for_properties = graph_model.get('properties', None)
        properties = {}
        if recipe_for_properties is not None:
            # the properties are extracted with the recipe consisting of an xpath and a method
            properties = self.find_properties(element, recipe_for_properties)
        if graph_model:  # not a terminal leaf node
            text = element.text
            if text:  # add the text property only if there is text
                properties['text'] = text
        else:  # terminal leaf node
            text = inner_text(element)
            if text:
                properties['text'] = inner_text(element)
        tail = element.tail
        if tail:
            properties['tail'] = tail
        properties['position_idx'] = position_idx
        # remove hyphens and namespace prefix
        self.properties = cleanup_properties(properties)
        self.children = self.find_children(element, graph_model.get('children', None))

    def find_properties(self, element, recipe: Dict):
        properties = {}
        for property, rec in recipe.items():
            xpath, funct = rec[0], rec[1]  # rec[2] 'as_list' only present when necessary
            try:
                target_elements = element.xpath(xpath, namespaces=self.namespaces)
            except XPathEvalError as e:
                print(f"Error with {xpath}")
                print(f"{element.tag} with {element.attrib}")
                raise e
            target_value = []
            if 'as_list' in rec:  # target value as a list of values for each element returned by xpath
                for e in target_elements:
                    val = funct(e)
                    if val is not None:
                        target_value.append(val)
            elif target_elements:
                target_value = funct(target_elements[0])
            if target_value:
                properties[property] = target_value
        return properties

    def find_children(self, element, graph_model):
        graph = {}
        if graph_model is not None:
            for relationship in graph_model:
                xp = graph_model[relationship]['XPath']
                sub_model = graph_model[relationship]
                elements = element.xpath(xp, namespaces=self.namespaces)
                sub_graph = [XMLNode(e, sub_model, position_idx=i, namespaces=self.namespaces) for i, e in enumerate(elements)]
                graph[relationship] = sub_graph
        return graph

    def to_str(self, indent=0):
        indentation = "    " * indent
        s = ""
        s += indentation + f"({self.label} {self.properties})\n"
        for rel in self.children:
            s += indentation + f"-[{rel}]->\n"
            for c in self.children[rel]:
                s += indentation + c.to_str(indent+1) + "\n"
        return s

    def __str__(self):
        return self.to_str()


def build_neo_graph(xml_node: XMLNode, source: str, db: Instance):
    properties = xml_node.properties  # deal with types!
    properties['source'] = source
    node = db.node(xml_node)
    print(f"loaded {xml_node.label} as node {node.id}                                ", end="\r")
    for rel, children in xml_node.children.items():
        for child in children:
            child_node = build_neo_graph(child, source, db)
            if rel is not None:
                db.relationship(node, child_node, rel)
    return node


class SDNeo:

    def __init__(self, api):
        self.api = api

    def create_graph(self, collection_name):
        collection = self.api.collection(collection_name)
        self.create_articles(collection.children)
        return collection


    def create_articles(self, article_list):
        articles, article_nodes, skipped_articles = self.create_nodes(self.api.article, article_list)
        if skipped_articles:
            logger.warning(f"Skipped articles: {', '.join([a.doi for a in skipped_articles])}")
        for a, a_node in zip(articles, article_nodes):
            if not a.doi:
                logger.warning(f"!!!! Article '{a.title}'' has no doi.")
                print(f"!!!! Article '{a.title}'' has no doi.")
            else:
                logger.info(f"article {a.doi}")
                print(f"article {a.doi}")
                figure_nodes = self.create_figures(a.children, a.doi)
                self.create_relationships(a_node, figure_nodes, 'has_fig')
        return article_nodes


    def create_figures(self, figure_list, doi):
        figures, figure_nodes, skipped_figures = self.create_nodes(self.api.figure, figure_list, doi)
        if skipped_figures:
            logger.warning(f"Skipped figures: {', '.join([f.fig_label for f in skipped_figures])}")
        if not (figures and figure_nodes):
            logger.warning(f"!!!! skipped creating any figure for {doi}")
            print(f"!!!! skipped creating any figure for {doi}")
        else:
            for f, f_nodes in zip(figures, figure_nodes):
                logger.info(f"    figure {f.fig_label}")
                print(f"    figure {f.fig_label}")
                panel_nodes = self.create_panels(f.children)
                self.create_relationships(f_nodes, panel_nodes, 'has_panel')
        return figure_nodes

    def create_panels(self, panel_list):
        panels, panel_nodes, skipped_panels = self.create_nodes(self.api.panel, panel_list)
        if skipped_panels:
            logger.warning(f"Skipped panels: {', '.join([p.panel_label for p in skipped_panels])}")
        if not (panels and panel_nodes):
            logger.warning(f"!!!! skipped creating any panels.")
            print(f"!!!! skipped creating any panels.")
        else:
            for p, p_node in zip(panels, panel_nodes):
                logger.info(f"        panel {p.panel_label}")
                print(f"        panel {p.panel_label}")
                tag_nodes = self.create_tags(p.children)
                self.create_relationships(p_node, tag_nodes, 'has_tag')
        return panel_nodes

    def create_tags(self, tag_list):
        tags, tag_nodes, skipped_tags = self.create_nodes(self.api.tag, tag_list)
        return tag_nodes

    @staticmethod
    def create_nodes(api_method, item_list, *args):
        items = []
        skipped = []
        nodes = None
        for item in item_list:
            a = api_method(item, *args)
            if a is not None:
                items.append(a)
            else:
                skipped.append(item)
        time.sleep(0.1)
        if items:
            label = items[0].label
            batch = [n.properties for n in items]
            nodes = DB.batch_of_nodes(label, batch)
        return items, nodes, skipped

    @staticmethod
    def create_relationships(source, targets, rel_label):
        rel = None
        if targets:
            rel_batch = [{'source': source.id, 'target': target.id} for target in targets]
            rel = DB.batch_of_relationships(rel_batch, rel_label)
        return rel
