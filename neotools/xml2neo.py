from lxml.etree import Element, XPathEvalError
from typing import Dict
import re
from .db import Instance
from .utils import inner_text


def cleanup_name(name):
    hyphen = re.compile(r'-')
    ns_prefix = re.compile(r'^{\S+}')
    name = hyphen.sub('_', name)
    name = ns_prefix.sub('', name)
    return name


def cleanup_properties(properties):
    clean_prop = {cleanup_name(k): v for k, v in properties.items()}
    return clean_prop


class XMLNode:
    """
    Nodes formed by recursively traversing the xml tree using the graph model.
    The properties of the nodes are generated by using the recipe provided by the graph model.
    Properties, including 'text' and 'tail', are only created if they are not empty or None.
    Terminal leaf nodes have no children and the innertext is then used as text property.
    The graph model provides the relationships to each subset of children.
    Each subset has an XPath to extract the respective children from the current element.

    Args:
        element (Element): the xml element to use to creat the node
        graph_model (Dict): the current graph model
        position_idx (int): the position of the element if it is part of a sequence
        namespaces (Dict): the dictionary of namespaces with their prefix

    Attributes:
        label (str): the node label
        properties (Dict): the properties of the node
        children (Dict): dictionary of childrens, where keys are relationship and value are the subgraph models

    """

    def __init__(self, element: Element, graph_model: Dict, position_idx: int = None, namespaces: Dict = None):
        # this_element_path_was = graph_model['XPath']
        # this_element_children = graph_model['children']
        # this_element_xpath_to_properties = graph_model['properties']
        self.namespaces = namespaces
        self.label = cleanup_name(element.tag).capitalize()
        print(f"parsing {self.label} {position_idx if position_idx is not None else ''}                               ", end="\r")
        recipe_for_properties = graph_model.get('properties', None)
        properties = {}
        if recipe_for_properties is not None:
            # the properties are extracted with the recipe consisting of an xpath and a method
            properties = self.find_properties(element, recipe_for_properties)
        if graph_model:  # not a terminal leaf node
            text = element.text
            if text: # add the text property only if there is text
                properties['text'] = text
        else:  # terminal leaf node
            text = inner_text(element)
            if text:
                properties['text'] = inner_text(element)
        tail = element.tail
        if tail:
            properties['tail'] = tail
        if position_idx is not None:
            properties['position_idx'] = position_idx
        # remove hyphens and namespace prefix
        self.properties = cleanup_properties(properties)
        self.children = self.find_children(element, graph_model.get('children', None))

    def find_properties(self, element, recipe: Dict):
        properties = {}
        for property, rec in recipe.items():
            xpath, funct = rec[0], rec[1]  # rec[2] 'as_list' only present when necessary
            try:
                target_elements = element.xpath(xpath, namespaces=self.namespaces)
            except XPathEvalError as e:
                print(f"Error with {xpath}")
                print(f"{element.tag} with {element.attrib}")
                raise e
            target_value = []
            if 'as_list' in rec:  # target value as a list of values for each element returned by xpath
                for e in target_elements:
                    val = funct(e)
                    if val is not None:
                        target_value.append(val)
            elif target_elements:
                target_value = funct(target_elements[0])
            if target_value:
                properties[property] = target_value
        return properties

    def find_children(self, element, graph_model):
        graph = {}
        if graph_model is not None:
            for relationship in graph_model:
                xp = graph_model[relationship]['XPath']
                sub_model = graph_model[relationship]
                elements = element.xpath(xp, namespaces=self.namespaces)
                add_index = len(elements) > 1
                sub_graph = []
                for i, e in enumerate(elements):
                    if add_index:
                        sub_graph.append(XMLNode(e, sub_model, position_idx=i, namespaces=self.namespaces))
                    else:
                        sub_graph.append(XMLNode(e, sub_model, namespaces=self.namespaces))
                graph[relationship] = sub_graph
        return graph

    def to_str(self, indent=0):
        indentation = "    " * indent
        s = ""
        s += indentation + f"({self.label} {self.properties})\n"
        for rel in self.children:
            s += indentation + f"-[{rel}]->\n"
            for c in self.children[rel]:
                s += indentation + c.to_str(indent+1) + "\n"
        return s

    def __str__(self):
        return self.to_str()


def build_neo_graph(xml_node: XMLNode, source: str, db: Instance):
    properties = xml_node.properties  # deal with types!
    properties['source'] = source
    node = db.node(xml_node)
    print(f"loaded {xml_node.label} as node {node.id}                                ", end="\r")
    for rel, children in xml_node.children.items():
        for child in children:
            child_node = build_neo_graph(child, source, db)
            db.relationship(node, child_node, rel)
    return node
