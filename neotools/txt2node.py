from lxml.etree import Element, XPathEvalError, parse
from io import BytesIO
from typing import Dict
import re
import json
from .model import (
    JATS_GRAPH_MODEL,
    CORD19_GRAPH_MODEL,
    # BIORXIV_API_GRAPH_MODEL,
    CROSSREF_PREPRINT_API_GRAPH_MODEL
)
from .utils import inner_text


# def compile(graph_model: Dict, namespaces: Dict = namespaces):
#     graph_model['XPath'] = XPath(graph_model['Xpath'], namespaces=namespaces)
#     for rel in graph_model['children']:
#         compile(graph_model['children'][rel], namespaces=namespaces)


def cleanup_name(name):
    hyphen = re.compile(r'-')
    ns_prefix = re.compile(r'^{\S+}')
    name = hyphen.sub('_', name)
    name = ns_prefix.sub('', name)
    return name


def cleanup_properties(properties):
    clean_prop = {cleanup_name(k): v for k, v in properties.items()}
    return clean_prop


class XMLNode:
    """
    Nodes formed by recursively traversing the xml tree using the graph model.
    The properties of the nodes are generated by using the recipe provided by the graph model.
    Properties, including 'text' and 'tail', are only created if they are not empty or None.
    Terminal leaf nodes have no children and the innertext is then used as text property.
    The graph model provides the relationships to each subset of children.
    Each subset has an XPath to extract the respective children from the current element.

    Args:
        element (Element): the xml element to use to creat the node
        graph_model (Dict): the current graph model
        position_idx (int): the position of the element if it is part of a sequence
        namespaces (Dict): the dictionary of namespaces with their prefix

    Attributes:
        label (str): the node label
        properties (Dict): the properties of the node
        children (Dict): dictionary of childrens, where keys are relationship and value are the subgraph models

    """

    def __init__(self, element: Element, graph_model: Dict, position_idx: int = 0, namespaces: Dict = None):
        # this_element_path_was = graph_model['XPath']
        # this_element_children = graph_model['children']
        # this_element_xpath_to_properties = graph_model['properties']
        self.namespaces = namespaces
        self.label = cleanup_name(element.tag).capitalize()
        print(f"parsing {self.label} {position_idx}                               ", end="\r")
        recipe_for_properties = graph_model.get('properties', None)
        properties = {}
        if recipe_for_properties is not None:
            # the properties are extracted with the recipe consisting of an xpath and a method
            properties = self.find_properties(element, recipe_for_properties)
        if graph_model:  # not a terminal leaf node
            text = element.text
            if text and not re.match(r'^\s+$', text):  # add the text property only if there is text
                properties['text'] = text
        else:  # terminal leaf node
            text = inner_text(element)
            if text:
                properties['text'] = text
        tail = element.tail
        if tail and not re.match(r'^\s+$', tail):
            properties['tail'] = tail
        properties['position_idx'] = position_idx
        # remove hyphens and namespace prefix
        self.properties = cleanup_properties(properties)
        self.children = self.find_children(element, graph_model.get('children', None))

    def find_properties(self, element, recipe: Dict):
        properties = {}
        for property, rec in recipe.items():
            xpath, funct = rec[0], rec[1]  # rec[2] 'as_list' only present when necessary
            try:
                target_elements = element.xpath(xpath, namespaces=self.namespaces)
            except XPathEvalError as e:
                print(f"Error with {xpath}")
                print(f"{element.tag} with {element.attrib}")
                raise e
            target_value = []
            if 'as_list' in rec:  # target value as a list of values for each element returned by xpath
                for e in target_elements:
                    val = funct(e)
                    if val is not None:
                        target_value.append(val)
            elif target_elements:  # take value only from the first element of the list
                target_value = funct(target_elements[0])
            if target_value:
                properties[property] = target_value
        return properties

    def find_children(self, element, graph_model):
        graph = {}
        if graph_model is not None:
            for relationship in graph_model:
                xp = graph_model[relationship]['XPath']
                sub_model = graph_model[relationship]
                elements = element.xpath(xp, namespaces=self.namespaces)
                sub_graph = [XMLNode(e, sub_model, position_idx=i, namespaces=self.namespaces) for i, e in enumerate(elements)]
                graph[relationship] = sub_graph
        return graph

    def to_str(self, indent=0):
        indentation = "    " * indent
        s = ""
        s += indentation + f"({self.label} {self.properties})\n"
        for rel in self.children:
            s += indentation + f"-[{rel}]->\n"
            for c in self.children[rel]:
                s += indentation + c.to_str(indent+1) + "\n"
        return s

    def __str__(self):
        return self.to_str()


class JSONNode:
    """
    Nodes formed by recursively traversing the json tree using the graph model.
    The properties of the nodes are generated by using the recipe provided by the graph model.
    Properties, including 'text' and 'tail', are only created if they are not empty or None.
    Terminal leaf nodes have no children and the innertext is then used as text property.
    The graph model provides the relationships to each subset of children.
    Each subset has a list of keys to extract the respective children from the current element.

    Args:
        element (Dict): the dict to use to creat the node
        graph_model (Dict): the current graph model
        position_idx (int): the position of the element if it is part of a sequence
        namespaces (Dict): the dictionary of namespaces with their prefix

    Attributes:
        label (str): the node label
        properties (Dict): the properties of the node
        children (Dict): dictionary of childrens, where keys are relationship and value are the subgraph models

    """

    def __init__(self, element: Dict, graph_model: Dict, position_idx: int = 0):
        self.label = cleanup_name(graph_model['path']['type']).capitalize()
        print(f"parsing {self.label} {position_idx}                               ", end="\r")
        recipe_for_properties = graph_model.get('properties', None)
        properties = {}
        if recipe_for_properties is not None:
            # the properties are extracted with the recip
            properties = {key: funct(element) for key, funct in recipe_for_properties.items()}
        properties['position_idx'] = position_idx
        # remove hyphens and namespace prefix
        self.properties = cleanup_properties(properties)
        self.children = self.find_children(element, graph_model.get('children', None))

    def find_children(self, element, graph_model):
        graph = {}
        if graph_model is not None:
            for relationship in graph_model:
                sub_model = graph_model[relationship]
                extractor = sub_model['path']['funct']
                elements = extractor(element)
                sub_graph = [JSONNode(e, sub_model, position_idx=i) for i, e in enumerate(elements)]
                graph[relationship] = sub_graph
        return graph

    def to_str(self, indent=0):
        indentation = "    " * indent
        s = ""
        s += indentation + f"({self.label} {self.properties})\n"
        for rel in self.children:
            if self.children[rel]: s += indentation + f"-[{rel}]->\n"
            for c in self.children[rel]:
                s += indentation + c.to_str(indent+1) + "\n"
        return s

    def __str__(self):
        return self.to_str()


def self_test():

    jats_example = b'''<?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.2d1 20170631//EN" "JATS-archivearticle1.dtd">
    <article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" article-type="article" dtd-version="1.2d1" specific-use="production" xml:lang="en">
        <front>
            <article-meta>
                <article-id pub-id-type="doi">10.1101/2020.03.02.972935</article-id>
                <article-version>1.1</article-version>
                <title-group>
                    <article-title>Isolation 'and' "characterization"  $of {SARS-CoV-2} from H&#x00F4;pital Bichat the first \US COVID-19 patient</article-title>
                </title-group>
                <abstract>This is the abstract.</abstract>              
                <contrib-group>
                    <contrib contrib-type="author">
                        <contrib-id contrib-id-type="orcid">http://orcid.org/0000-0002-1012-2226</contrib-id>
                        <name><surname>Liu</surname><given-names>Chuang</given-names></name>
                        <xref ref-type="aff" rid="a1">1</xref>
                        <xref ref-type="aff" rid="a3">3</xref>
                        <xref ref-type="author-notes" rid="n2">&#x002A;</xref>
                    </contrib>
                    <contrib contrib-type="author">
                        <name><surname>Yang</surname><given-names>Yang</given-names></name>
                        <xref ref-type="aff" rid="a2">2</xref>
                        <xref ref-type="author-notes" rid="n2">&#x002A;</xref>
                    </contrib>
                </contrib-group>
                <pub-date pub-type="epub"><year>2020</year></pub-date>
                <article-categories>
                    <subj-group subj-group-type="author-type">
                        <subject>Regular Article</subject>
                    </subj-group>
                    <subj-group subj-group-type="heading">
                        <subject>New Results</subject>
                    </subj-group>
                    <subj-group subj-group-type="hwp-journal-coll">
                        <subject>Microbiology</subject>
                    </subj-group>
                </article-categories>
            </article-meta>
        </front>
        <body>
            THis and that.
            <fig>
                <label>Figure 3</label>
                <caption>This is nice.</caption>
                <graphic xlink:href="http://this.com/figure/3"/>
            </fig>
        </body>
    </article>
    '''

    tree = parse(BytesIO(jats_example))
    xml_element = tree.getroot()
    jats_graph = XMLNode(xml_element, JATS_GRAPH_MODEL)
    print(jats_graph)

    cord_example = {
        "paper_id": "0b159ec402f822d502c0a2a478f5e08c1212acb5",
        "metadata": {
            "title": "Cloning and characterization of a putative mouse acetyl-CoA transporter cDNA",
            "authors": [
                {
                    "first": "Roop",
                    "middle": [],
                    "last": "Singh Bora",
                    "email": ""
                },
                {
                    "first": "Akiko",
                    "middle": [],
                    "last": "Kanamori",
                    "suffix": "",
                    "affiliation": {
                        "laboratory": "Laboratory for Cellular Glycobiology",
                        "institution": "The Institute of Physical and Chemical Research",
                        "location": {
                            "addrLine": "2-1 Hirosawa",
                            "postCode": "351-0198",
                            "settlement": "Wako",
                            "region": "Saitama",
                            "country": "Japan"
                        }
                    },
                    "email": ""
                },
            ],
        },
        "abstract": [
            {
                "text": "blah blah blah",
                "section": "Abstract"
            },
            {
                "text": "following up: blah.",
                "section": "abstract"
            }
        ],
        "ref_entries": {
            "FIGREF0": {
                "text": "Nucleotide sequence and predicted amino-acid sequence of brane domain III. This motif is often found in the mouse Acatn cDNA. The potential N-linked glycosylation sites are enclosed in the boxes. The putative leucine zipper motif is underlined. transporter proteins(Eckhardt et al., 1996;Abeijon The nucleotide sequence data will appear in the DDBJ/EMBL/ et al., 1996).GenBank nucleotide sequence databases with the accession number Homology searches of mouse Acatn against currently AB016795.",
                "latex": None,
                "type": "figure"
            },
            "FIGREF1": {
                "text": "Immunocytochemical analysis to study the expression of O-acetylated gangliosides in the transfected cells. HeLa/GT3+ cells were transfected with vector pcDNA3.1 (A) or pcDNA3.1-Acatn (B). Bar=20 mm.",
                "latex": None,
                "type": "figure"
            },
        }
    }
    cord_example['metadata']['doi'] = "sdlkfjsdlkfjsf"
    cord_example['metadata']['pub_date'] = "2020-05-30"    
    cord_n = JSONNode(cord_example, CORD19_GRAPH_MODEL)
    print(cord_n)

    # biorxiv_api_example = '''{
    #     "doi": "10.1101\/2020.02.12.944629",
    #     "title": "Retrocopying expands the functional repertoire of APOBEC3 antiviral proteins in primates",
    #     "authors": "Yang, L.; Emerman, M.; Malik, H. S.; McLaughlin, R. N.",
    #     "author_corresponding": "Richard N McLaughlin Jr.",
    #     "author_corresponding_institution": "Pacific Northwest Research Institute, Fred Hutchinson Cancer Research Center",
    #     "date": "2020-02-13",
    #     "version": "1",
    #     "license": "cc_by_nc",
    #     "type": "new results",
    #     "category": "genomics",
    #     "abstract": "...",
    #     "published": "10.7554\/eLife.58436"
    # }'''
    # j = json.loads(biorxiv_api_example)
    # biorxiv_api_n = JSONNode(j, BIORXIV_API_GRAPH_MODEL)
    # print(biorxiv_api_n)

    cross_ref_example = '''
    {
        "institution": {
            "name": "bioRxiv",
            "place": ["-"],
            "acronym": ["-"]
        },
        "indexed": {
            "date-parts": [[2020, 5, 9]], 
            "date-time": "2020-05-09T05:10:49Z",
            "timestamp": 1589001049133
        },
        "posted": {
            "date-parts": [[2020, 2, 13]]
        }, 
        "group-title": "Genomics", 
        "reference-count": 95, 
        "publisher": "Cold Spring Harbor Laboratory", 
        "content-domain": {
            "domain": [], 
            "crossmark-restriction": "False"
        }, 
        "accepted": {
            "date-parts": [[2020, 5, 5]]
        }, 
        "abstract": "...",
        "DOI": "10.1101/2020.02.12.944629",
        "type": "posted-content", 
        "created": {
            "date-parts": [[2020, 2, 14]], 
            "date-time": "2020-02-14T05:35:26Z", 
            "timestamp": 1581658526000
        }, 
        "source": "Crossref", 
        "is-referenced-by-count": 0, 
        "title": "Retrocopying expands the functional repertoire of APOBEC3 antiviral proteins in primates", 
        "prefix": "10.1101", 
        "author": [
            {
                "ORCID": "http://orcid.org/0000-0001-9284-1744", 
                "authenticated-orcid": "False", 
                "given": "Lei", 
                "family": "Yang", 
                "sequence": "first", "affiliation": []
            },
            {
                "given": "Michael", "family": "Emerman", "sequence": "additional", "affiliation": []
            }, 
            {
                "given": "Harmit S.", "family": "Malik", "sequence": "additional", "affiliation": []
            }, 
            {
                "ORCID": "http://orcid.org/0000-0003-0950-2253", "authenticated-orcid": "False", "suffix": "Jr.", "given": "Richard N.", "family": "McLaughlin", "sequence": "additional", "affiliation": []
            }
        ], 
        "member": "246", 
        "reference": [
            {"key": "2020050808162359000_2020.02.12.944629v2.1", "DOI": "10.3389/fmicb.2012.00275", "doi-asserted-by": "publisher"}
        ],
        "container-title": [], 
        "original-title": [], 
        "link": [
            {
                "URL": "https://syndication.highwire.org/content/doi/10.1101/2020.02.12.944629", 
                "content-type": "unspecified", 
                "content-version": "vor", 
                "intended-application": "similarity-checking"
            }
        ], 
        "deposited": {
            "date-parts": [[2020, 5, 8]], 
            "date-time": "2020-05-08T15:16:34Z", 
            "timestamp": 1588950994000
        }, 
        "score": 1.0, 
        "subtitle": [], 
        "short-title": [], 
        "issued": {
            "date-parts": [[2020, 2, 13]]
        }, 
        "references-count": 95, 
        "URL": "http://dx.doi.org/10.1101/2020.02.12.944629", 
        "relation": {"cites": []}, 
        "subtype": "preprint"
    }
    '''
    j = json.loads(cross_ref_example)
    cross_ref_example_n = JSONNode(j, CROSSREF_PREPRINT_API_GRAPH_MODEL)
    print(cross_ref_example_n)


if __name__ == '__main__':
    self_test()
